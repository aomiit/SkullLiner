/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
#include "autoNeuro.h"
/* Header for class jAutoPano */

#ifndef _Included_jAutoPano
#define _Included_jAutoPano
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     jAutoPano
 * Method:    libapGenerateCurveFromRaw
 * Signature: (Ljava/lang/String;IZ)J
 */
JNIEXPORT jfloatArray JNICALL Java_jAutoPano_libapGenerateCurveFromRaw
  (JNIEnv *env, jobject obj, jstring pathRaw)
{
	// Assign the input RAW file path to the library
	const char *strPathRaw =	 env->GetStringUTFChars( pathRaw, NULL );
	AutoNeuro* autoN = new AutoNeuro();
	unsigned int dim[3] = {400,400,300};
	unsigned int maxPoints = 1024;
	unsigned int maxIter = 10;
	unsigned long maxMem = 250*1024*1024; // Maximum 250 MB allowed
	autoN->setCriteria( maxPoints, maxIter, maxMem, dim );
	autoN->registerPotentialInputNo( strPathRaw );
	vector<CvPoint2D32f> points = autoN->generateOutputCurve2( 60 );

	env->ReleaseStringUTFChars( pathRaw, strPathRaw );

	// Convert vector of 3D points to the Java-compatible array of floating points
	size_t numElems = points.size()*2+1;
	jfloat* elems = new jfloat[ numElems ];
	vector<CvPoint2D32f>::iterator p = points.begin();
	int index=0;
	while (p!=points.end())
	{
		elems[index] = (*p).x;
		elems[++index] = (*p).y;
		index++;
		p++;
	}
	// Terminate the list with -1 (Just for reliability check)
	elems[points.size()*2] = -1;

	// --
	jfloatArray returnList = env->NewFloatArray( numElems );
	env->SetFloatArrayRegion( returnList, 0, numElems, elems );

	autoN->clean();
	delete autoN;
	return returnList;
}


JNIEXPORT jint JNICALL Java_jAutoPano_libTest(JNIEnv *env, jobject obj)
{
	return 1;
}



JNIEXPORT jfloatArray JNICALL Java_jAutoPano_libapGenerateCurveFromRawEx
  (JNIEnv *env, jobject obj, jdoubleArray dataArray, jint width, jint height)
{
	// Assign the input RAW file path to the library
	AutoNeuro* autoN = new AutoNeuro();
	unsigned int dim[3] = {width,height,1};
	unsigned int maxPoints = 1024;
	unsigned int maxIter = 10;
	unsigned long maxMem = 250*1024*1024; // Maximum 250 MB allowed

	// Read array of double from the input arguments
	jdouble* pixels = env->GetDoubleArrayElements( dataArray, NULL );
	jsize pixelCount = env->GetArrayLength( dataArray );

	// Create image matrix from the dataArray
	CvMat* matRaw = cvCreateMat( height, width, CV_8UC1 );
	for (register int i=0; i<width; i++)
		for (register int j=0; j<height; j++)
		{
			// Read jDoubleArray element in the right manner
			cvSetReal2D( matRaw, j, i, autoN->convert16bitTo8bit( pixels[j+i*width]) );
		}

	// Dispose the prepared array instantly after use
	env->ReleaseDoubleArrayElements( dataArray, pixels, 0 );

	autoN->setCriteria( maxPoints, maxIter, maxMem, dim );
	autoN->registerPotentialInputNo( matRaw );
	vector<CvPoint2D32f> points =  autoN->generateOutputCurve2( 60 );

	// Convert vector of 3D points to the Java-compatible array of floating points
	size_t numElems = points.size()*2+1;
	jfloat* elems = new jfloat[ numElems ];
	vector<CvPoint2D32f>::iterator p = points.begin();
	int index=0;
	while (p!=points.end())
	{
		elems[index] = (*p).x;
		elems[++index] = (*p).y;
		index++;
		p++;
	}
	// Terminate the list with -1 (Just for reliability check)
	elems[points.size()*2] = -1;

	// --
	jfloatArray returnList = env->NewFloatArray( numElems );
	env->SetFloatArrayRegion( returnList, 0, numElems, elems );

	delete []elems;
	delete autoN;
	return returnList;
}

#ifdef __cplusplus
}
#endif
#endif
